# -*- coding: utf-8 -*-
"""HelperFuncs_SP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1babvC4Nc6ovIX0iaP-ydT4Y_ItiaTGr4
"""

# Commented out IPython magic to ensure Python compatibility.
# @title Import a buncha libraries

!pip install nilearn --quiet
!pip install hcp_utils --quiet

import os
import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt
from nilearn import plotting
import hcp_utils as hcp
import ipywidgets as widgets
import seaborn as sns
from sklearn.decomposition import FastICA

# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

"""#Cifti Data Loader Funcs"""

# @title Helper function for Data Loader

def load_data(EXP, APorPA):
    run = EXP
    filename = os.path.join(DATA_DIR, fname_ex, f'tfMRI_RET{run}_7T_{APorPA}.dtseries.nii')
    cifti = nib.load(filename)
    data = cifti.get_fdata()

    return data, cifti

"""#Fast ICA"""

# @title Helper function to perform ICA

def perform_ica(data, comp=20):
    ica = FastICA(n_components=comp, random_state=42)
    comp = ica.fit_transform(data.T)

    return comp

# @title Paired sample t-test for comparing ICA component
def paired_ICA(data1, data2):
  from scipy import stats

  # Compute correlation matrices
  correlation_matrix_1 = np.corrcoef(data1, rowvar=False)
  correlation_matrix_2 = np.corrcoef(data2, rowvar=False)

  # Compare correlation matrices statistically
  t_stat, p_val = stats.ttest_rel(correlation_matrix_1, correlation_matrix_2)

  for i in range(len(t_stat)):
    print('[t, p] =', (round(t_stat[i],2), round(p_val[i], 2)))

  return t_stat, p_val



"""#Helper funcs for plotting on Brain"""

# @title Helper function for plotting on Brain

def surf_data_from_cifti(data, cifti, surf_name):
  surf_name_long = 'CIFTI_STRUCTURE_CORTEX_'+surf_name
  axis = cifti.header.get_axis(1)  # The brain axis
  for name, data_indices, model in axis.iter_structures():
    if name == surf_name_long:
      vtx_indices = model.vertex
      surf_data = np.zeros(axis.nvertices[surf_name_long])
      surf_data[vtx_indices] = data[data_indices]
      return surf_data
  raise ValueError(f"No structure named {surf_name_long}")

def plot_on_brain(data, cifti, hemisphere, brain_shape):
    if hemisphere == "LEFT":
        abbr = "L"
    else:
        abbr = "R"
    filename = f'Q1-Q6_R440.{abbr}.{brain_shape}.32k_fs_LR.surf.gii' #input data name
    pathf = os.path.join(DATA_DIR, fname_ex, "surf", filename)
    brain_plot = plotting.view_surf(surf_mesh=pathf, surf_map=surf_data_from_cifti(data,cifti,hemisphere), cmap='Blues', threshold=0.0001)

    return brain_plot

"""#Connectivity matrix"""

# @title Helper function for plotting connectivity matrix of ICA components

def plot_connectivity_matrix(ica_comp):
    correlation_matrix = np.corrcoef(ica_comp.T)
    plt.figure(figsize=(10, 8))
    sns.heatmap(correlation_matrix, cmap='coolwarm', annot=False)
    plt.title('Functional Connectivity Matrix (ICA)')
    plt.xlabel('IC Components')
    plt.ylabel('IC Components')
    plt.show()

"""#Pearson correlation coefficient"""

# @title Helper function for Pearson correlational coefficient
from scipy.stats import pearsonr

def find_correlation(data1, data2):
    voxel_count = data1.shape[1]
    corr_coeff = np.zeros(voxel_count)
    for i in range(voxel_count):
        X = data1[:,i]
        Y = data2[:,i]
        correlation_coefficient, _ = pearsonr(X, Y)
        corr_coeff[i] = correlation_coefficient

    return corr_coeff

corr = np.empty((x,y)) #indicate the shape of matrix
n, m = corr.shape

# @title Helper function for Pearson correlational coefficient for 2 datasets
def corr_matrx(Xp1, Xp2, m, n):
  'Xp: a 2d matrix, independent component x time series'
  'm, n: the value of row & column of the matrix'
  for i in range(n):
    for j in range(m):
      correlation_matrix = np.corrcoef(Xp1[i,:], Xp2[j,:])
      correlation_coefficient = correlation_matrix[0,1]
      corr[i, j] = correlation_coefficient

  return corr

# @title Helper function for Pearson correlational coefficient plot [Triangle]

def plot_coeff(correlation_matrix, xlables, ylabels):
  'x/ylabels: a list of names of each component'
  corr_matrix = correlation_matrix

  # Generate a mask for the upper triangle
  mask = np.triu(np.ones_like(corr_matrix, dtype=bool))

  # Create a custom diverging colormap
  cmap = sns.diverging_palette(230, 20, as_cmap=True)

  plt.figure(figsize=(10, 10))
  sns.heatmap(corr_matrix, mask=mask, cmap=cmap, vmax=1, vmin=-1,
              square=True, linewidths=.5, cbar_kws={"shrink": .5},
              annot=True, fmt=".2f", annot_kws={"size": 10},
              xticklabels=xlabels, yticklabels=ylabels)

  plt.title('Correlation matrix', fontsize=20)

  plt.show()

# @title Helper function for Pearson correlational coefficient plot [Normal]
def plot_coeff(correlation_matrix):
  plt.figure(figsize=(10, 8))
  sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
  plt.title('Correlation heatmap of components')
  plt.show()

"""# HCP parcellation atlas

##Using GLM to plot predicted brain map
"""

# @title Set a buncha variables, download data and extract

DATA_DIR = "./hcp_retino"
if not os.path.isdir(DATA_DIR):
  os.mkdir(DATA_DIR)
TR = 1
RUN_NAMES = [
  "BAR1",
  "BAR2",
  "CCW",
  "CW",
  "EXP",
  "CON"
]
import os, requests, tarfile
fname = "hcp_retino.tgz"
url = "https://osf.io/d25b4/download"

if not os.path.isfile(fname):
  try:
    r = requests.get(url)
  except requests.ConnectionError:
    print("!!! Failed to download data !!!")
  else:
    if r.status_code != requests.codes.ok:
      print("!!! Failed to download data !!!")
    else:
      print(f"Downloading {fname}...")
      with open(fname, "wb") as fid:
        fid.write(r.content)
      print(f"Download {fname} completed!")
fname_ex = "HCP7T_retino"
path_name = os.path.join(DATA_DIR, fname_ex)
if not os.path.exists(path_name):
  print(f"Extracting {fname}...")
  with tarfile.open(f"{fname}") as fzip:
    fzip.extractall(DATA_DIR)
else:
  print(f"File {fname}.tgz has already been extracted.")

# @title Helper function for Data Loader

def load_data(EXP, APorPA):
    run = EXP
    filename = os.path.join(DATA_DIR, fname_ex, f'tfMRI_RET{run}_7T_{APorPA}.dtseries.nii')
    cifti = nib.load(filename)
    data = cifti.get_fdata()

    return data, cifti

data_ccw, cifti_ccw = load_data("CCW", "AP")
data_cw, cifti_cw = load_data("CW", "PA")

# @title Create a sinusoidal design_matrix inspired by stimulus timings

n_before, period, cycles, n_after = 22, 32, 8, 22
t = np.arange(0, period * cycles, 1/TR)
time_var_cos = np.concatenate((np.zeros(n_before), np.cos(2 * np.pi * t / period), np.zeros(n_after)))
time_var_sin = np.concatenate((np.zeros(n_before), np.sin(2 * np.pi * t / period), np.zeros(n_after)))
design_matrix = np.asarray([time_var_cos, time_var_sin, np.ones_like(time_var_sin)]).T

# @title Helper function to fit the design_matrix to data

def fit_sinusoid(data, design_matrix):
    beta = np.linalg.pinv(design_matrix) @ data
    prediction = design_matrix @ beta

    return beta, prediction

beta_ccw, pred_ccw = fit_sinusoid(data_ccw, design_matrix)
beta_cw, pred_cw = fit_sinusoid(data_cw, design_matrix)

# @title Normalize the dataset

ccw_norm = hcp.normalize(pred_ccw)
cw_norm = hcp.normalize(pred_cw)

# @title Play with timesteps for connected components in CCW

@widgets.interact(
    t = widgets.IntSlider(value=158, min=0, max=300, step=1)
)

def COI(t):
    n_components, sizes, rois = hcp.cortical_components(ccw_norm[t]>1.0, cutoff=36)
    plot = plotting.view_surf(hcp.mesh.inflated, hcp.cortex_data(hcp.mask(ccw_norm[t], rois==1)), threshold=0.001, bg_map=hcp.mesh.sulc, cmap="hsv")
    return plot

"""##HCP parcellation"""

img = nib.load('/content/hcp_retino/HCP7T_retino/tfMRI_RETCW_7T_PA.dtseries.nii')
X = img.get_fdata()
X.shape     # e.g. (300, 91282)

X_hipL = X[:, hcp.struct.hippocampus_left]
X_hipL.shape    # (300, 764)

Xn = hcp.normalize(X)

Xp = hcp.parcellate(Xn, hcp.yeo7)
Xp.shape    # (300, 7)

hcp.parcellate(Xn, hcp.yeo7, method=np.amax)

df = hcp.ranking(Xp[29], hcp.yeo7)
df

n_components, sizes, rois = hcp.cortical_components(Xn[29]>1.0, cutoff=36)
n_components, sizes

